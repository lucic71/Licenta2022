\section{Porting IxOS on ARM Boards}
\subsection{Previous IxOS Architecture}
\subsection{New IxOS Architecture}

\subsection{The Porting Process}

The porting process consisted in moving the IxOS testing infrastructure from its
source environment to a new target environment consisting of an off-the-shelf
ARM board, RaspberryPi, running a stock Linux operating system. When we started
the porting we set the following porting milestones:
\begin{itemize}
    \item Separate Interface Manager from IxOS in a git repository
    \item Run Interface Manager in QEMU
    \item Run Interface Manager on RaspberryPi hardware
\end{itemize}
We achieved all our proposed milestones during the twelve weeks of the project.
At the end of the project we divided the work into three logical stages
that cover the process of achieving the above milestones.

\subsubsection{Porting Stages}

The logical stages of our porting process are the following:
\begin{itemize}
    \item Build binaries for ARM64
    \begin{itemize}
        \item Separate IM + HostProxy from IxOS infrastructure
        \item Integrate IxStack with IM
        \item Build plugins for IM
        \item Test initial builds in QEMU
    \end{itemize}
    \item Emulate vCard on RPi
    \begin{itemize}
        \item Run setup on RPi hardware
        \item Hack IM to work properly
        \item Send stat requests to ixStatDaemon to check if the stats are working
    \end{itemize}
    \item Bring up ports on vChassis
    \begin{itemize}
        \item Check where the link state gets assigned to kVirtualModuleNotReady
        \item Track the path to link state = kUp
        \item Solve the DOD problem that generated our link state issue
    \end{itemize}
\end{itemize}
These stages with their respective substages were not completed in chronological
order. The process of completion was rather incremental, meaning that for
example we had to test the initial builds in QEMU each time we made a
modification in the "Integrate IxStack in IM" stage, going back and forth
between the two substages.

In the first stage, we started the work of porting by trying to separate the
relevant components from IxOS and build them for ARM64. We started with
Interface Manager and HostProxy, which were the building block of our porting,
and continued with IxStack and its components. The hardware was not available
at this time so we tested our builds using an emulator for the target
architecture (i.e., QEMU).

Next, when the hardware arrived, we used the RaspberryPi to test our builds.
This proved to be a great advantage for us because the testing environment
worked better on hardware than in the emulator. After we built all our
components, we started to focus on the inconsistencies between the source
environment and the target environment. For that we had to hack some parts of
the program or we had to make portable and consistent changes. However the
porting did not run as smoothly as we expected. We had to investigate multiples
paths to understand the problems we faced, namely the problems regarding the
initialization of our vCard. For that we investigated the stat daemon hoping
that we would solve the initializaton problems. Unfortunately we did not have
success with this approach and went to stage three.

In stage three we investigated the initialization problems from another
perspective. This time we investigated what was the initialization sequence on
IxServer. Here we discovered that IxServer did not set the link state correctly
when connecting to our vCard. To solve that we tracked the variables and code
zones that modify the link state in order to find out which code lines cause
trouble. In the end we discovered that a problem regarding the initialization
of DownloadOnDemand components was causing our start-up issues. After we solved
these issues we were able to fully port Interface Manager on RaspberryPi and
integrate it with the bigger system consisting of IxServer and IxExplorer.

\subsubsection{Porting Difficulties}

TODO: maybe put the difficulties in a table to be easier to read?

Each stage came with its own difficulties that we needed to solve in order to
move to the next stages. In this section we will present the most relevant
impediments we faced in each stage.

\paragraph{Build binaries for ARM64}

The first and most difficult impediment we faced when trying to move the build
system from the source environment to ARM64 was to understand the architecture
and design of the code and the build system. The documentation was lacking so
we had to rely on our experience with the system in order to understand the
peculiarities of each component. We did not spend much time on understanding the
code architecture, rather we spent time on understanding the build system
because we wanted to deliver working binaries for ARM64 as soon as possible.

The build system used SCons, rather than classic Makefile, which required us to
use a system that ran python2 out of the box or install it using unconventional
methods because python2 is no longer supported on most systems. After we
modified the build system and generated binaries for ARM64 we had to test them
in an emulated environment because hardware was not available at that time. Our
solution was to use QEMU which caused us problems while testing the builds.
The speed of the operating system running inside QEMU was awfully slow. This
meant that we had to wait a considerable time for installing our builds on the
machine, running the ported application and analyzing the output so that we
could solve the eventual inconsistencies.

After the hardware arrived, we were able to test our build in a faster
environment.

\paragraph{Emulate vCard on RPi}

At this time we had to prepare the target environment for a more advanced
type of testing. Until this point we were solving start-up issues with regards
to Interface Manager. Now we had to prepare the communication environment with
other components as IxServer and IxExplorer. Before placing our RaspberryPi
environment in the same network as IxServer we had to work with a clumsy
configuration: IxServer ran in a Virtual Box machine and the RaspberryPi was
connected to the computer that ran VirtualBox. To connect the two we had to make
a bridge between the Virtual Box network and the host network. This did not work
as expected because this configuration broke the IxServer machine.

When we succedded in putting the RaspberryPi in the same network as IxServer,
we faced problems with the Linux operating system running on vCard (i.e.,
Raspberry Pi OS). dmidecode(8) did not work on this system because the operating
system did not allow us to access /dev/kmem. Another problem we faced featured
the assumptions Interface Manager made about the environment it run in. In its
source environment it relied on many Ixia custom device drivers and ioctl's.
In the target environment, these interfaces did not exist so we had to somehow
skip their usage.

After we solved all the problems regarding the interaction of Interface Manager
with the new environment, we stepped in stage three where we solved the
communication problems of Interface Manager with the other components (i.e.,
IxServer and IxExplorer).

\paragraph{Bring up ports on vChassis}

In this stage the most difficult impediment we faced was figuring out what went
wrong when IxServer was communicating with vCard. We had no reference
communication so we had to rely on trial and error methods to find out what went
wrong.

Firstly, we tried to investagate if the problem was with vCard stats. We assumed
that the vCard did not initialize correctly when communicating with IxServer
because it did not send periodical statistics. However this proved to be false,
but it came with a rather huge cost. We spent approximatively three days trying
to see if the problem was the statistics.

Secondly, we focused on the code in IxServer, leaving behind vCard. The code is
written in C++, using an object oriented paradigm. The coding style helped us
to surf faster through the code and filter unimportant code zones. However the
difficulty here was the code size. We had to read multiple thousand-lines files
in order to find the communication problem. Because of time considerents we
only patched the code in IxServer side, without modifying the vCard.

\subsection{General difficulties}

After describing the concrete impediments we faced during our porting we decided
to understand them and create a list with general difficulties that may apply
to other porting processes. The list is found in Figure~\ref{tab:portImpeds}.

\begin{table*}
\centering
\begin{tabular}{|p{5cm}|p{10cm}|}
\hline
Difficulty & Details \\
\hline
Lacking documentation & Lacking written documentation about how the system works means
that the developer must either figure out the system alone or must communicate
with other developers in order to gather information about the system. This adds
overhead to the porting process as documentation through communication is
slower than documentation through written text.\\
\hline
Inconsistencies between environments & This difficulty corresponds to the
degree of which the application is portable~\cite{b5}. If the degree of
portability is too low (this depends entirely on the application) then the
developer will be faced with many inconsistencies between the source and target
environments that will be reflected in the cost of porting (i.e., man-hours). \\
\hline
Use of tools & Using inadequate development and testing tools introduces additional
overhead in the porting process. This happens when the used tools are either
outdated or too hard to use for the purpose of the process. \\
\hline
Understanding the system & Software complexity is a multi-dimensional problem,
it includes: structural, computational, logical, conceptual and textual complexity.
~\cite{b6} There is no easy way to understand the system, so the developer will
be faced with the task of understanding the architecture diagrams, huge code
base, written documents and tutorials either when the porting starts or during
the porting process. \\
\hline
Unexpected difficulties & As with every software process, there are difficulties
that can not be estimated beforehand. They include unknown parts of the software
that may cause problems when ported or assumptions about the environment made by
the system that will not work in the target environment. The only time they
are clearly reflected in the porting costs is at the end of the project where
a retrospective is led. \\
\hline
\end{tabular}
\caption{General porting difficulties}
\label{tab:portImpeds}
\end{table*}
