\section{Porting IxOS on ARM Boards}
\subsection{Previous IxOS Architecture}
\subsection{New IxOS Architecture}

\subsection{The Porting Process}

The porting process consisted in moving the IxOS testing infrastructure from its
source environment to a new target environment consisting of an off-the-shelf
ARM board, RaspberryPi, running a stock Linux operating system. When we started
the porting we set the following porting milestones:
\begin{itemize}
    \item Separate Interface Manager from IxOS in a git repository
    \item Run Interface Manager in QEMU
    \item Run Interface Manager on RaspberryPi hardware
\end{itemize}
We achieved all our proposed milestones during the twelve weeks of the project.
At the end of the project we divided the work into three logical stages
that cover the process of achieving the above milestones.

\subsubsection{Porting Stages}

The logical stages of our porting process are the following:
\begin{itemize}
    \item Build binaries for ARM64
    \begin{itemize}
        \item Separate IM + HostProxy from IxOS infrastructure
        \item Integrate IxStack with IM
        \item Build plugins for IM
        \item Test initial builds in QEMU
    \end{itemize}
    \item Emulate vCard on RPi
    \begin{itemize}
        \item Run setup on RPi hardware
        \item Hack IM to work properly
        \item Send stat requests to ixStatDaemon to check if the stats are working
    \end{itemize}
    \item Bring up ports on vChassis
    \begin{itemize}
        \item Check where the link state gets assigned to kVirtualModuleNotReady
        \item Track the path to link state = kUp
        \item Solve the DOD problem that generated our link state issue
    \end{itemize}
\end{itemize}
These stages with their respective substages were not completed in chronological
order. The process of completion was rather incremental, meaning that for
example we had to test the initial builds in QEMU each time we made a
modification in the "Integrate IxStack in IM" stage, going back and forth
between the two substages.

In the first stage, we started the work of porting by trying to separate the
relevant components from IxOS and build them for ARM64. We started with
Interface Manager and HostProxy, which were the building block of our porting,
and continued with IxStack and its components. The hardware was not available
at this time so we tested our builds using an emulator for the target
architecture (i.e., QEMU).

Next, when the hardware arrived, we used the RaspberryPi to test our builds.
This proved to be a great advantage for us because the testing environment
worked better on hardware than in the emulator. After we built all our
components, we started to focus on the inconsistencies between the source
environment and the target environment. For that we had to hack some parts of
the program or we had to make portable and consistent changes. However the
porting did not run as smoothly as we expected. We had to investigate multiples
paths to understand the problems we faced, namely the problems regarding the
initialization of our vCard. For that we investigated the stat daemon hoping
that we would solve the initializaton problems. Unfortunately we did not have
success with this approach and went to stage three.

In stage three we investigated the initialization problems from another
perspective. This time we investigated what was the initialization sequence on
IxServer. Here we discovered that IxServer did not set the link state correctly
when connecting to our vCard. To solve that we tracked the variables and code
zones that modify the link state in order to find out which code lines cause
trouble. In the end we discovered that a problem regarding the initialization
of DownloadOnDemand components was causing our start-up issues. After we solved
these issues we were able to fully port Interface Manager on RaspberryPi and
integrate it with the bigger system consisting of IxServer and IxExplorer.
