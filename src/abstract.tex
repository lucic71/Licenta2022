\newcommand{\AbstractRO}{
Portarea software e costisitoare și consumatoare de timp. Refolosirea
software-ului a devenit o practică standard în ingineria software datorită
beneficilor sale de salvare a costurilor, astfel e important să înțelegem cadrul
de cuantificare al costurilor de refolosire astfel încât procesul să poată fi
optimizat. Ca să explorăm această problematică, luăm ca exemplu experiența
noastră de portare a infrastructurii de testare Ixia pe un sistem off-the-shelf,
popular, cu suport pentru Linux, cum ar fi Raspberry Pi și extragem costurile de
portare asociate cu acest proces. Acest lucru ne ajută să creăm un model
revizuit al portării pe baza căruia extragem costurile de portare pentru
proiectul nostru. Mai mult de atât, prezentăm factorii care au afectat portarea
și corespondența lor directă cu modelul de portare și costurile asociate.
Descoperim că procesul de portare nu e liniar dependent de gradul de
portabilitate al sistemului, acesta depinde foarte mult de familiaritatea
dezvoltatorului cu sistemul. În sfârșit, discutăm limitările modelului nostru de
portare și facem o comparație cu modelul vechi de portare.  }

\newcommand{\AbstractEN}{
The software porting process is costly and time consuming. Software reuse has
become a standard practice in software engineering due to its cost saving
benefits, therefore it is important to understand the framework for quantifying
the costs of reuse so that the process can be optimized. In order to explore
this issue, we take our experience of porting the Ixia network testing
infrastructure on a popular, off-the-shelf system that supports Linux, such as
Raspberry Pi and extract the porting costs associated with this process. This
leads us to a revised model of porting based on which we extract the costs for
our project. Furthermore we present the factors that affect the porting and their
direct correspondence with the porting model and costs. We discover that the
porting process is not linearly dependent on the degree of portability of the
system, it very much depends on the familiarity of the developer with the
system. Finally, we discuss the limitations of our porting model and make a
comparison with the old porting model.  }
